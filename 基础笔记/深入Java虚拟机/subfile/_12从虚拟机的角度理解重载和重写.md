# 从虚拟机的角度理解重载和重写

> 说明：本文主要内容都参考至《深入Java虚拟机-周志明著》

Class文件的编译过程中不包含传统程序语言编译的连接步骤，**一切方法的调用在Class文件里面存储的都只是符号引用**，而不是方法在实际运行时内存布局的入口地址（也就是直接引用）。这种特性给Java带来的更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂，某些调用只能在类加载期间，甚至运行期间才能确定目标方法的直接引用。

## 1. 解析

前面说到一切方法的调用在Class文件里面存储的都只是符号引用，在类加载时期的解析阶段，会将其中一部分符号引用转化为直接引用。这种解析的前提是：方法在程序真正运行前就有一个可确定的调用版本，并且这个方法的调用版本在运行时是不可变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就确定下来。这类方法的调用被称为解析（Resolution）。

**解析是一个静态的过程，在编译器期间就完全确定，在类加载的解析阶段就会把设计的符号引用全部转变为明确的直接引用**。在Java语言中符合这种要求的方法，主要有静态方法和私有方法两大类。前者与类型直接绑定，后者在外部不能访问且不可继承。所以这两种特性决定它们不能通过继承或别的方式重写出其它版本，因此它们都适合在加载阶段进行解析。

调用不同类型的方法，在Java虚拟机中对应着不同的指令。在Java虚拟机中支持一下五种方法调用指令：

- `invokestatic`：调用静态方法
- `invokespecial`：调用实例的构造器`<init>()`方法、私有方法和父类中的方法。
- `invokevirtual`：调用接口中的方法，会在运行时再确定一个实现该接口的对象。
- `invokedynamic`：先运行时解析出调用点限定符所引用的方法，然后再执行该方法。前面四条指令，分派逻辑都固话在虚拟机内部，而`invokedynamic`指令的分派逻辑由用户设定的引导方法来决定的。

只要能被`invokestatic`和`invokespecial`指令调用的方法，都可以在解析阶段中确定唯一的调用版本。

## 2. 分派

众所周知，Java是一门面向对象的程序语言。它具备三种最基本的特性：继承、封装和多态。我们通过分派的学习中可以掌握多态特性中一些最基本的体现，也就是重写和重载在Java虚拟机中是如何实现的，它们是如何正确找到自己的调用版本的。

### 2.1 静态分派



