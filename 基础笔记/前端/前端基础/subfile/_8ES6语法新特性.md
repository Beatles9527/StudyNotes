# ES6语法新特性

- [一. let](#let/var)
- [二. const](#const)
- [三. 对象的增强写法](#对象的增强写法)
  - [3.1 属性的增强写法](#属性的增强写法)
  - [3.2 函数的增强写法](#函数的增强写法)
- [四. 箭头函数](#箭头函数)

## 一. let <a name="let/var"> </a>

事实上var的设计可以看成JavaScript语言设计上的错误。但是为了向后兼容这些错误不能被修复。于是var关键字的替代者：

- **var属于ES5规范，let属于ES6规范**
- **let变量不能重复声明**
- **var有预处理机制，let没有。预处理机制也就是常说的声明提前**。
  - 　**声明提前：**不管变量被声明在函数什么位置，所有变量声明都会被提升至函数顶部（变量声明指 var a; 即声明还未赋值）比如声明变量**a**并赋值为**1**，即 **var a = 1;**  则 **var a;**会被提升至函数顶部 （只是a被提前，a的值1不会被提前）

下面立即函数执行后，控制台不会打印出**1**，而是**undefined**，因为只有声明被提前，值没有

```javascript
<script>
    (function() {
        console.log(a);
        var a = 1;
    })()
</script>
```

下面立即执行函数执行后，控制台不会打印出**1**和**undefined**，而是报错，因为let声明的变量不会被提前

```javascript
<script>
    (function() {
        console.log(a);
        let a = 1;
    })()
</script>
```

- **作用域的不同，var是全局作用域，let是块级作用域**。

下面代码控制台会打印出1　

```javascript
<script>    
     if(true) {
         var a = 1;
     }
     console.log(a);
 </script>
```

下面代码控制台不会打印出1，会报错，提示a没有定义（let定义的变量只在{}里才能访问到）

```javascript
<script>
    if(true) {
        var let = 1;
    }
    console.log(a);
</script>
```

**前方高能**，没有块级作用域会造成的后果：

我们尝试创建三个按钮，然后通过循环给这些按钮加上点击事件，试图在点击“按钮一”时打印“第1个按钮被点击了”，但是我们使用var这个关键字进行循环绑定事件，最终会发现三个按钮全部都是打印的是"第3个..."，这就是因为var关键字这个变量没有块作用域，事件绑定的三个函数实际上都是应用的for循环中的i，但是等创建绑定完成后i已经变成了3了。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <button>按钮1</button>
    <button>按钮2</button>
    <button>按钮3</button>
</body>
<script>
    let buttons = document.getElementsByTagName("button");
    for (var i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click',function () {
            alert("第"+i+"个按钮被点击了");
        })
    }
</script>
</html>
```

此时如果我们将for循环中的var改为let就可以恢复正常了。

## 二. const<a name="const"> </a>

const用于定义常量：

- const创建常量时必须初始化。

- 初始化后的常量不可修改，如果该常量是一个对象，那这个对象内部的属性可以修改。

- const拥有块级作用域

  ```js
  function fun(){
      const xx = "qwe";
  }
  console.info(xx);//报错
  ```

## 三. 对象的增强写法<a name="对象的增强写法"> </a>

### 3.1 属性的增强写法<a name="属性的增强写法"> </a>

ES5中创建字面量对象时使用已经创建好的常量值做属性值是这样写的：

```java
 const name = "张三";
 const age = 19;
 const obj = {
     name: name,
     age: age
 }
 console.log(obj);
```

ES6中可以这么写：直接使用常量值创建属性，key就是常量的名称，value就是常量的实际值。

```javascript
const name = "张三";
const age = 19;
const obj = {
    name,
    age
}
console.log(obj);
```

### 3.2 函数的增强写法<a name="函数的增强写法"> </a>

在ES5中创建一个函数需要这么写：

```javascript
const obj = {
    name: "xxx",
    age: 18,
    run: function () {
        console.info(this.name+"正在运行")
    }
}
```

在ES6中可以这样写：

```javascript
const obj = {
    name: "xxx",
    age: 18,
    run() {
        console.info(this.name+"正在运行")
    }
}
```

## 四. 变量解构赋值

ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值。

### 4.1 数组的结构赋值

ES5的写法：

```js
arr = ['张三','李四','王五'];
var zhangsan = arr[0];
var lisi = arr[1];
var wangwu = arr[2];

console.info(zhangsan);
console.info(lisi);
console.info(wangwu);
```

ES6解构赋值：

```js
arr = ['张三','李四','王五'];
let [zhangsan,lisi,wangwu] = arr;

console.info(zhangsan);
console.info(lisi);
console.info(wangwu);
```

### 4.2 对象的结构赋值

ES5写法：

```js
const zhao = {
    name: '赵本山',
    age: 66,
    xiaopin: function(){
        console.info("我会演小品");
    }
}

var name = zhao.name;
var age = zhao.age;
var xiaopin = zhao.xiaopin;
```

ES6结构赋值：

```js
const zhao = {
    name: '赵本山',
    age: 66,
    xiaopin: function(){
        console.info("我会演小品");
    }
}

let {age,name,xiaopin} = zhao;
xiaopin();
```

## 五. 模板字符串

ES6引入了模板字符串：

- 模板字符串中可以包含换行符。
- 可以使用`${}`动态插入数据。

```js
let content = `
        <div>
          <div></div>
        </div>
    `;
```

```js
let str="Hello World!"
let content = `
    <div>
      <div>${str}</div>
    </div>
`;
```

## 六. 函数<a name="箭头函数"> </a>

### 6.1 箭头函数

#### 6.1.1 箭头函数基本使用

ES6标准新增了一种新的函数：Arrow Function（箭头函数）。箭头函数相当于匿名函数，并且简化了函数定义。

```js
//ES5：
var sum = funciton(a,b){
    return a + b;
}

//ES6：
let sum = (a, b) => a + b;

console.info(sum(1,2));
```

箭头函数有两种格式，一种像上面的，只包含一个表达式，连`{ ... }`和`return`都省略掉了。还有一种可以包含多条语句，这时候就不能省略`{ ... }`和`return`：

- 当入参只有一个参数时，小括号可以省略
- 当函数体只有一行，并且这一行需要return，则可以省略大括号以及return关键字。

```javascript
x => {
    if (x > 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}
```

如果参数不是一个，就需要用括号`()`括起来：

```javascript
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：

```javascript
// SyntaxError:
x => { foo: x }
```

因为和函数体的`{ ... }`有语法冲突，所以要改为：

```javascript
// ok:
x => ({ foo: x })
```

#### 6.1.2 箭头函数特性

- **箭头函数的this指针是静态的，它始终是指向函数声明时所在作用域下this的值**。实际原因是**箭头函数根本没有自己的this**，导致内部的this就是**外层代码块**的this。

```java
var x = 11;
var obj = {
    x: 22,
    say: ()=>{
        console.log(this.x);
    }
}
var obj2 = {
    x: 33,
    say: function() {
        console.log(this.x);
    }
}
obj.say();  // 输出的值为11。因为obj对象的this指针是指向window的，所以定义在它内部的say箭头函数的this是window.
obj2.say(); // 输出值为33
```

而对于下面的例子：

```js
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 28
```

例子中**箭头函数本身是在getAge方法中定义的**，因此，getAge方法的**父执行上下文**是obj，因此这里的this指向则为obj对象。

箭头函数在声明时就已经固化，即使使用call函数调用也无法改变this指针的指向：

```js
let school = {
    name: '李四'
}

window.name = "张三";

function getName() {
    console.info(this.name);
}

let getName2 = () => {console.info(name)};

getName.call(school)；
getName2.call(school);
```

call方法可以改变普通函数的this指针，所以`getName`打印的是`school.name`（李四）；而由于箭头函数的this指针是静态的，所以`getName2`还是打印的`window.name`（张三）。[call方法调用](./_12JS中Call方法调用.md)

- 正是因为箭头函数没有this，所以也就**不能用作构造函数**。

```js
//ES5函数可以作为构造函数
function Hello(a, b) {
    this.a = a;
    this.b = b;
}
let hello1 = new Hello('1','2');
```

- 不能使用Arguments变量

```js
function fn1(a,b){
    console.info(arguments);
}
fn2 = (a,b)=>{
    console.info(arguments);//报错
}
fn1();
fn2();
```

### 6.2 参数默认值

```js
function hello (a, b, c = 10) {
    console.info(a)
    console.info(b)
    console.info(c)
}
hello(1,2)
```

参数默认值还可与解构赋值相结合：

```js
let info = {
    host: '192.168.0.2'
}
function connect({host='127.0.0.1',port=3306}){
    console.info(host);
    console.info(port);
}
connect(info)
```

### 6.3 可变参数

```js
function hello(...arr){
    console.info(arr);
}
hello(1,2,3,4);
```

## 七. 扩展运算符

ES5：

```js
let persons = ['张三','李四','王五'];
function hello(a,b,c){
    console.info(a);
    console.info(b);
    console.info(c);
}

hello(persons[0],persons[1],persons[2]);
```

ES6扩展运算符：

```js
let persons = ['张三','李四','王五'];
function hello(a,b,c){
    console.info(a);
    console.info(b);
    console.info(c);
}

hello(...persons);
```



