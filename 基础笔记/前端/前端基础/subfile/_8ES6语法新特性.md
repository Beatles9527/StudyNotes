# ES6语法新特性

- [一. let](#let/var)
- [二. const](#const)
- [三. 对象的增强写法](#对象的增强写法)
  - [3.1 属性的增强写法](#属性的增强写法)
  - [3.2 函数的增强写法](#函数的增强写法)
- [四. 箭头函数](#箭头函数)

## 一. let <a name="let/var"> </a>

事实上var的设计可以看成JavaScript语言设计上的错误。但是为了向后兼容这些错误不能被修复。于是var关键字的替代者：

- **var属于ES5规范，let属于ES6规范**
- **var有预处理机制，let没有。预处理机制也就是常说的声明提前**。
  - 　**声明提前：**不管变量被声明在函数什么位置，所有变量声明都会被提升至函数顶部（变量声明指 var a; 即声明还未赋值）比如声明变量**a**并赋值为**1**，即 **var a = 1;**  则 **var a;**会被提升至函数顶部 （只是a被提前，a的值1不会被提前）

下面立即函数执行后，控制台不会打印出**1**，而是**undefined**，因为只有声明被提前，值没有

```javascript
<script>
    (function() {
        console.log(a);
        var a = 1;
    })()
</script>
```

下面立即执行函数执行后，控制台不会打印出**1**和**undefined**，而是报错，因为let声明的变量不会被提前

```javascript
<script>
    (function() {
        console.log(a);
        let a = 1;
    })()
</script>
```

- **作用域的不同，var是全局作用域，let是块级作用域**。

下面代码控制台会打印出1　

```javascript
<script>    
     if(true) {
         var a = 1;
     }
     console.log(a);
 </script>
```

下面代码控制台不会打印出1，会报错，提示a没有定义（let定义的变量只在{}里才能访问到）

```javascript
<script>
    if(true) {
        var let = 1;
    }
    console.log(a);
</script>
```

前方高能，没有块级作用域会造成的后果：

我们尝试创建三个按钮，然后通过循环给这些按钮加上点击事件，试图在点击“按钮一”时打印“第1个按钮被点击了”，但是我们使用var这个关键字进行循环绑定事件，最终会发现三个按钮全部都是打印的是"第3个..."，这就是因为var关键字这个变量没有块作用域，事件绑定的三个函数实际上都是应用的for循环中的i，但是等创建绑定完成后i已经变成了3了。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <button>按钮1</button>
    <button>按钮2</button>
    <button>按钮3</button>
</body>
<script>
    let buttons = document.getElementsByTagName("button");
    for (var i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click',function () {
            alert("第"+i+"个按钮被点击了");
        })
    }
</script>
</html>
```

## 二. const<a name="const"> </a>

const用于定义常量：

- const创建常量时必须初始化。
- 初始化后的常量不可修改，如果该常量是一个对象，那这个对象内部的属性可以修改。



## 三. 对象的增强写法<a name="对象的增强写法"> </a>

### 3.1 属性的增强写法<a name="属性的增强写法"> </a>

ES5中创建字面量对象时使用已经创建好的常量值做属性值是这样写的：

```java
 const name = "张三";
 const age = 19;
 const obj = {
     name: name,
     age: age
 }
 console.log(obj);
```

ES6中可以这么写：直接使用常量值创建属性，key就是常量的名称，value就是常量的实际值。

```javascript
const name = "张三";
const age = 19;
const obj = {
    name,
    age
}
console.log(obj);
```

### 3.2 函数的增强写法<a name="函数的增强写法"> </a>

在ES5中创建一个函数需要这么写：

```javascript
const obj = {
    name: "xxx",
    age: 18,
    run: function () {
        console.info(this.name+"正在运行")
    }
}
```

在ES6中可以这样写：

```javascript
const obj = {
    name: "xxx",
    age: 18,
    run() {
        console.info(this.name+"正在运行")
    }
}
```

## 四. 箭头函数<a name="箭头函数"> </a>

ES6标准新增了一种新的函数：Arrow Function（箭头函数）。箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连`{ ... }`和`return`都省略掉了。还有一种可以包含多条语句，这时候就不能省略`{ ... }`和`return`：

```javascript
x => {
    if (x > 0) {
        return x * x;
    }
    else {
        return - x * x;
    }
}
```

如果参数不是一个，就需要用括号`()`括起来：

```javascript
// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}
```

如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：

```javascript
// SyntaxError:
x => { foo: x }
```

因为和函数体的`{ ... }`有语法冲突，所以要改为：

```javascript
// ok:
x => ({ foo: x })
```

### this

箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的`this`是词法作用域，由上下文确定。

回顾前面的例子，由于JavaScript函数对`this`绑定的错误处理，下面的例子无法得到预期结果：

```javascript
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};
```

现在，箭头函数完全修复了`this`的指向，`this`总是指向词法作用域，也就是外层调用者`obj`：

```javascript
var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
```

如果使用箭头函数，以前的那种hack写法：

```javascript
var that = this;
```

就不再需要了。

由于`this`在箭头函数中已经按照词法作用域绑定了，所以，用`call()`或者`apply()`调用箭头函数时，无法对`this`进行绑定，即传入的第一个参数被忽略：

```javascript
var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) => y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25
```