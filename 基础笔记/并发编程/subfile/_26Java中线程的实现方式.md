## JAVA中线程的实现方式

> 说明：本文转载至《深入Java虚拟机》第三版第十二章第4节

实现线程主要有三种方式：使用内核线程实现（1:1）实现；使用用户线程实现（1:N）模式；使用使用用户线程+内核线程混合实现（N:M）。

## 一. 内核线程实现

内核线程（Kernel-Level Thread）就是直接由操作系统内核（Kernel）支持的线程，这种线程由内核来来完成线程切换，内核通过操纵调度器（Scheduler）对线程实行调度，并负责将将线程的任务映射到处理器上。

程序一般不会直接使用内核线程，而会使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程所支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一线程模型。

![](E:/GitHub_Reporsitory/StudyNotes/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/images/44.png)

轻量级进程具有一定的局限性：首先，由于基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程是有限的。

## 二. 用户线程实现

使用用户线程实现的方式被称为1:N实现。广义上来讲一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）的一种，因此从这个定义上来看，轻量级进程也属于用户线程，但轻量级进程始终是建立在内核之上的，许多操作都需要进行系统调用，因此效率会受到限制，并不具备通常意义上的用户线程的优点。

而狭义的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步与销毁完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以非常快速且低消耗的，也因此可以支持更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1:N的关系称为一对多线程模型。

![](E:/GitHub_Reporsitory/StudyNotes/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/images/45.png)

用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作操作都需要由用户程序自己去处理。线程的创建、销毁、切换和调度都是用户必须考虑的问题，而且操作系统只把处理器资源分配给进程，那诸如“阻塞如何处理” “多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的。因为使用用户线程实现的程序通常都比较复杂，除了有明确需求外（譬如以前不支持多线程的操作系统中的多线程程序、需要支持大规模线程数量的应用），一般的应用程序都不倾向于使用用户线程。Java、Rubby等语言都曾经使用过用户线程，最终又都放弃使用它。但是今年来许多新的、以高并发为卖点的编程语言又普遍支持了用户线程，譬如Golang、Erlang等，使得用户线程有所回升。

## 三. 混合实现

混合实现下，及存在用户线程也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核线程提供线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不固定的，是N:M的关系。

![](E:/GitHub_Reporsitory/StudyNotes/%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/images/46.png)

## 四. Java线程的实现

Java线程如何实现实际上并不受Java虚拟机规范的约束，这是一个与具体虚拟机相关的话题。Java线程在早期的 Cases虚拟机上(JDK 1.2以前)，是基于一种被称为“绿色线程"(Green Thread)的用户线程实现的，但从JDK1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1:1线程模拟。

以HotSpot虚拟机为例，它的每一个Java虚拟机线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的，全权交由操作系统去处理，所以合适冻结或唤醒线程、该给线程分配多少处理执行时间、该把线程安排给哪个处理器核心去执行等都是有操作系统完成的，也都是由操作系统全权决定的。

**需要注意的是：线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异式完全透明的**。