# 原子操作算法—CAS

## 1. 原子操作

在并发编程中，锁是消耗性能的操作，同一时间只能有一个线程进入同步块修改变量的值，比如下面的代码：

```java
synchronized void function(){
  i++；
}
```

使用同步锁自然可以达到操作的原子性，但是同步操作会造成额外的性能开销。我们有没有办法不使用锁呢？当然是可以的，此时就需要使用CAS算法。

## 2. 什么是CAS

CAS （Compare And Swap），中文叫比较交换，一种无锁原子算法。过程是这样：它包含 3 个参数 CAS（V，E，N），V表示内存中的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程则什么都不做。最后，CAS 会将旧值返回。CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。

当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。

与锁相比，使用CAS会使程序看起来更加复杂一些，但由于其非阻塞的，它对死锁问题天生免疫，并且，线程间的相互影响也非常小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，他要比基于锁的方式拥有更优越的性能。

简单的说，CAS 需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，哪说明它已经被别人修改过了。你就需要重新读取，再次尝试修改就好了。

## 3. CAS底层原理

CAS算法的核心思想就是“比较交换”，但是如果在操作系统底层“比较交换”不是一个原子操作，那样就并不能解决线程安全问题。其他线程仍然可以在当前线程进行比较操作后修改变量的值，此时当前线程不会意识到状态的改变，这同样会导致线程安全问题。

我们虽然可以使用同步代码块来实现“比较交换”的原子性，但是这就违背了CAS不使用锁的原则。真正实现CAS算法要归功于硬件指令集的发展，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。这类指令常用的有：

- 测试并设置（Tetst-and-Set）
- 获取并增加（Fetch-and-Increment）
- 交换（Swap）
- **比较并交换（Compare-and-Swap）**
- 加载链接/条件存储（Load-Linked/Store-Conditional）



## 4. CAS的问题

CAS并不是万能的，它可能会导致以下问题：

### 4.1 ABA问题

假设一个变量 A ，修改为 B之后又修改为 A，CAS 的机制是无法察觉的，但实际上已经被修改过了。如果在基本类型上是没有问题的，但是如果是引用类型呢？这个对象中有多个变量，我怎么知道有没有被改过？聪明的你一定想到了，加个版本号啊。每次修改就检查版本号，如果版本号变了，说明改过，就算你还是 A，也不行。

### 4.2 开销问题

首先我们需要明确的是如果CAS操作中，内存中的值与期望值不同会再次循环尝试，知道尝试成功，我们称之为自旋。

```java
for(;;){
	if(E==V){
		V = N;
	}
}
```



在极端情况下，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果jvm能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：

1. 它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。

2. 它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。

### 4.3 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个方法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i=2,j=a合并一下ij=2a，然后用CAS来操作ij。从java1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

**参考文章**：

https://blog.csdn.net/baidu_34168157/article/details/80966438

https://www.cnblogs.com/stateis0/p/9062006.html

https://www.cnblogs.com/liukaifeng/p/10052640.html